/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
'use strict';

var _objectSpread2 = require("@babel/runtime/helpers/interopRequireDefault")(require("@babel/runtime/helpers/objectSpread"));

var _inheritsLoose2 = require("@babel/runtime/helpers/interopRequireDefault")(require("@babel/runtime/helpers/inheritsLoose"));

/**
 * @public
 *
 * RelayReadyStateRenderer synchronously renders a container and query config
 * given `readyState`. The `readyState` must be an accurate representation of
 * the data that currently resides in the supplied `environment`. If you need
 * data to be fetched in addition to rendering, please use `RelayRenderer`.
 *
 * If `readyState` is not supplied, the previously rendered `readyState` will
 * continue to be rendered (or null if there is no previous `readyState`).
 */
var RelayReadyStateRenderer =
/*#__PURE__*/
function (_React$Component) {
  (0, _inheritsLoose2["default"])(RelayReadyStateRenderer, _React$Component);

  // TODO t16225453
  function RelayReadyStateRenderer(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    _this._relay = {
      environment: props.environment,
      variables: props.queryConfig.params,
      route: props.queryConfig
    };
    _this.state = {
      getContainerProps: createContainerPropsFactory()
    };
    return _this;
  }

  var _proto = RelayReadyStateRenderer.prototype;

  _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {
    if (this.props.environment !== nextProps.environment || this.props.queryConfig !== nextProps.queryConfig) {
      this._relay = {
        environment: nextProps.environment,
        variables: nextProps.queryConfig.params,
        route: nextProps.queryConfig
      };
    }
  };
  /**
   * Avoid updating when we have fetched data but are still not ready.
   */


  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    var prevProps = this.props;

    if (prevProps.Container !== nextProps.Container || prevProps.environment !== nextProps.environment || prevProps.queryConfig !== nextProps.queryConfig || prevProps.render !== nextProps.render || prevProps.retry !== nextProps.retry) {
      return true;
    }

    var prevReadyState = prevProps.readyState;
    var nextReadyState = nextProps.readyState;

    if (prevReadyState == null || nextReadyState == null) {
      return true;
    }

    if (prevReadyState.aborted !== nextReadyState.aborted || prevReadyState.done !== nextReadyState.done || prevReadyState.error !== nextReadyState.error || prevReadyState.ready !== nextReadyState.ready || prevReadyState.stale !== nextReadyState.stale) {
      return true;
    }

    return nextReadyState.ready;
  };

  _proto.render = function render() {
    var children;
    var shouldUpdate = false;
    var _this$props = this.props,
        readyState = _this$props.readyState,
        render = _this$props.render;

    if (readyState) {
      if (render) {
        children = render({
          done: readyState.done,
          error: readyState.error,
          events: readyState.events,
          props: readyState.ready ? this.state.getContainerProps(this.props) : null,
          retry: this.props.retry,
          stale: readyState.stale
        });
      } else if (readyState.ready) {
        var Container = this.props.Container;
        children = require("react").createElement(Container, this.state.getContainerProps(this.props));
      }

      shouldUpdate = true;
    }

    if (children === undefined) {
      children = null;
      shouldUpdate = false;
    }

    return require("react").createElement(require("./ReactRelayContext").Provider, {
      value: this._relay
    }, require("react").createElement(require("./RelayStaticContainer"), {
      shouldUpdate: shouldUpdate
    }, children));
  };

  return RelayReadyStateRenderer;
}(require("react").Component);

function createContainerPropsFactory() {
  var prevProps;
  var querySet;
  return function (nextProps) {
    if (!querySet || !prevProps || prevProps.Container !== nextProps.Container || prevProps.queryConfig !== nextProps.queryConfig) {
      querySet = require("./getRelayQueries")(nextProps.Container, nextProps.queryConfig);
    }

    var containerProps = (0, _objectSpread2["default"])({}, nextProps.queryConfig.params, require("fbjs/lib/mapObject")(querySet, function (query) {
      return createFragmentPointerForRoot(nextProps.environment, query);
    }));
    prevProps = nextProps;
    return containerProps;
  };
}

function createFragmentPointerForRoot(environment, query) {
  return query ? require("./RelayFragmentPointer").createForRoot(environment.getStoreData().getQueuedStore(), query) : null;
}

module.exports = RelayReadyStateRenderer;