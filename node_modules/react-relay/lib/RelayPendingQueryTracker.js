/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
'use strict';

/**
 * @internal
 *
 * Tracks pending (in-flight) queries.
 */
var RelayPendingQueryTracker =
/*#__PURE__*/
function () {
  // Asynchronous mapping from preload query IDs to results.
  function RelayPendingQueryTracker(storeData) {
    this._pendingFetchMap = {};
    this._preloadQueryMap = new (require("fbjs/lib/PromiseMap"))();
    this._storeData = storeData;
  }
  /**
   * Used by `GraphQLQueryRunner` to enqueue new queries.
   */


  var _proto = RelayPendingQueryTracker.prototype;

  _proto.add = function add(params) {
    return new PendingFetch(params, {
      pendingFetchMap: this._pendingFetchMap,
      preloadQueryMap: this._preloadQueryMap,
      storeData: this._storeData
    });
  };

  _proto.hasPendingQueries = function hasPendingQueries() {
    return hasItems(this._pendingFetchMap);
  };
  /**
   * Clears all pending query tracking. Does not cancel the queries themselves.
   */


  _proto.resetPending = function resetPending() {
    this._pendingFetchMap = {};
  };

  _proto.resolvePreloadQuery = function resolvePreloadQuery(queryID, result) {
    this._preloadQueryMap.resolveKey(queryID, result);
  };

  _proto.rejectPreloadQuery = function rejectPreloadQuery(queryID, error) {
    this._preloadQueryMap.rejectKey(queryID, error);
  };

  return RelayPendingQueryTracker;
}();
/**
 * @private
 */


var PendingFetch =
/*#__PURE__*/
function () {
  function PendingFetch(_ref, _ref2) {
    var fetchMode = _ref.fetchMode,
        forceIndex = _ref.forceIndex,
        query = _ref.query;
    var pendingFetchMap = _ref2.pendingFetchMap,
        preloadQueryMap = _ref2.preloadQueryMap,
        storeData = _ref2.storeData;
    var queryID = query.getID();
    this._forceIndex = forceIndex;
    this._pendingFetchMap = pendingFetchMap;
    this._preloadQueryMap = preloadQueryMap;
    this._query = query;
    this._resolvedDeferred = new (require("fbjs/lib/Deferred"))();
    this._resolvedQuery = false;
    this._storeData = storeData;
    this._fetchQueryPromise = fetchMode === require("./RelayFetchMode").PRELOAD ? this._preloadQueryMap.get(queryID) : storeData.getNetworkLayer().fetchRelayQuery(query);
    this._fetchedQuery = false;
    this._error = null;
    this._pendingFetchMap[queryID] = {
      fetch: this,
      query: query
    };

    require("./throwFailedPromise")(this._fetchQueryPromise.then(this._handleQuerySuccess.bind(this), this._handleQueryFailure.bind(this)));
  }

  var _proto2 = PendingFetch.prototype;

  _proto2.isResolvable = function isResolvable() {
    return this._resolvedQuery;
  };

  _proto2.getQuery = function getQuery() {
    return this._query;
  };

  _proto2.getResolvedPromise = function getResolvedPromise() {
    return this._resolvedDeferred.getPromise();
  };

  _proto2._handleQuerySuccess = function _handleQuerySuccess(result) {
    var _this = this;

    this._fetchedQuery = true;

    require("./throwFailedPromise")(this._storeData.getTaskQueue().enqueue(function () {
      var response = result.response;
      !(response && typeof response === 'object') ? process.env.NODE_ENV !== "production" ? require("fbjs/lib/invariant")(false, 'RelayPendingQueryTracker: Expected response to be an object, got ' + '`%s`.', response ? typeof response : response) : require("fbjs/lib/invariant")(false) : void 0;

      _this._storeData.handleQueryPayload(_this._query, response, _this._forceIndex);
    }).then(this._markQueryAsResolved.bind(this), this._markAsRejected.bind(this)));
  };

  _proto2._handleQueryFailure = function _handleQueryFailure(error) {
    this._markAsRejected(error);
  };

  _proto2._markQueryAsResolved = function _markQueryAsResolved() {
    var queryID = this.getQuery().getID();
    delete this._pendingFetchMap[queryID];
    this._resolvedQuery = true;

    this._updateResolvedDeferred();
  };

  _proto2._markAsRejected = function _markAsRejected(error) {
    var queryID = this.getQuery().getID();
    delete this._pendingFetchMap[queryID];
    console.warn(error.message);
    this._error = error;

    this._updateResolvedDeferred();
  };

  _proto2._updateResolvedDeferred = function _updateResolvedDeferred() {
    if (this._isSettled() && !this._resolvedDeferred.isSettled()) {
      if (this._error) {
        this._resolvedDeferred.reject(this._error);
      } else {
        this._resolvedDeferred.resolve(undefined);
      }
    }
  };

  _proto2._isSettled = function _isSettled() {
    return !!this._error || this._resolvedQuery;
  };

  return PendingFetch;
}();

function hasItems(map) {
  return !!Object.keys(map).length;
}

module.exports = RelayPendingQueryTracker;