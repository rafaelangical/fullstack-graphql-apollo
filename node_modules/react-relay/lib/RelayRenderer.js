/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
'use strict';

var _objectSpread2 = require("@babel/runtime/helpers/interopRequireDefault")(require("@babel/runtime/helpers/objectSpread"));

var _inheritsLoose2 = require("@babel/runtime/helpers/interopRequireDefault")(require("@babel/runtime/helpers/inheritsLoose"));

var _assertThisInitialized2 = require("@babel/runtime/helpers/interopRequireDefault")(require("@babel/runtime/helpers/assertThisInitialized"));

var _defineProperty2 = require("@babel/runtime/helpers/interopRequireDefault")(require("@babel/runtime/helpers/defineProperty"));

var INACTIVE_READY_STATE = {
  aborted: false,
  done: false,
  error: null,
  events: [],
  ready: false,
  stale: false
};
/**
 * @public
 *
 * RelayRenderer renders a container and query config after fulfilling its data
 * dependencies. Precise rendering behavior is configured via the `render` prop
 * which takes a callback.
 *
 * The container created using `Relay.createContainer` must be supplied via the
 * `Container` prop, and the query configuration that conforms to the shape of a
 * `RelayQueryConfig` must be supplied via the `queryConfig` prop.
 *
 * === Render Callback ===
 *
 * The `render` callback is called with an object with the following properties:
 *
 *   props: ?{[propName: string]: mixed}
 *     If present, sufficient data is ready to render the container. This object
 *     must be spread into the container using the spread attribute operator. If
 *     absent, there is insufficient data to render the container.
 *
 *   done: boolean
 *     Whether all data dependencies have been fulfilled. If `props` is present
 *     but `done` is false, then sufficient data is ready to render, but some
 *     data dependencies have not yet been fulfilled.
 *
 *   error: ?Error
 *     If present, an error occurred while fulfilling data dependencies. If
 *     `props` and `error` are both present, then sufficient data is ready to
 *     render, but an error occurred while fulfilling deferred dependencies.
 *
 *   retry: ?Function
 *     A function that can be called to re-attempt to fulfill data dependencies.
 *     This property is only present if an `error` has occurred.
 *
 *   stale: boolean
 *     When `forceFetch` is enabled, a request is always made to fetch updated
 *     data. However, if all data dependencies can be immediately fulfilled, the
 *     `props` property will be present. In this case, `stale` will be true.
 *
 * The `render` callback can return `undefined` to continue rendering the last
 * view rendered (e.g. when transitioning from one `queryConfig` to another).
 *
 * If a `render` callback is not supplied, the default behavior is to render the
 * container if data is available, the existing view if one exists, or nothing.
 *
 * === Refs ===
 *
 * References to elements rendered by the `render` callback can be obtained by
 * using the React `ref` prop. For example:
 *
 *   <FooComponent {...props} ref={handleFooRef} />
 *
 *   function handleFooRef(component) {
 *     // Invoked when `<FooComponent>` is mounted or unmounted. When mounted,
 *     // `component` will be the component. When unmounted, `component` will
 *     // be null.
 *   }
 *
 */

var RelayRenderer =
/*#__PURE__*/
function (_React$Component) {
  (0, _inheritsLoose2["default"])(RelayRenderer, _React$Component);

  function RelayRenderer(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    _this.mounted = true;
    _this.pendingRequest = null;
    _this.state = {
      active: false,
      readyState: null,
      retry: _this._retry.bind((0, _assertThisInitialized2["default"])((0, _assertThisInitialized2["default"])(_this)))
    };
    return _this;
  }

  var _proto = RelayRenderer.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this._validateProps(this.props);

    this._runQueries(this.props);
  };
  /**
   * @private
   */


  _proto._validateProps = function _validateProps(props) {
    var error = RelayRenderer.propTypes.Container(props, 'Container', 'RelayRenderer');

    if (error) {
      throw error;
    }
  };
  /**
   * @private
   */


  _proto._runQueries = function _runQueries(_ref) {
    var _this2 = this;

    var Container = _ref.Container,
        forceFetch = _ref.forceFetch,
        onForceFetch = _ref.onForceFetch,
        onPrimeCache = _ref.onPrimeCache,
        queryConfig = _ref.queryConfig,
        environment = _ref.environment,
        shouldFetch = _ref.shouldFetch;

    if (!shouldFetch) {
      return;
    }

    var onReadyStateChange = function onReadyStateChange(readyState) {
      if (!_this2.mounted) {
        _this2._handleReadyStateChange((0, _objectSpread2["default"])({}, readyState, {
          mounted: false
        }));

        return;
      }

      if (request !== _this2.lastRequest) {
        // Ignore (abort) ready state if we have a new pending request.
        return;
      }

      if (readyState.aborted || readyState.done || readyState.error) {
        _this2.pendingRequest = null;
      }

      _this2.setState({
        active: true,
        readyState: (0, _objectSpread2["default"])({}, readyState, {
          mounted: true
        })
      });
    };

    if (this.pendingRequest) {
      this.pendingRequest.abort();
    }

    var querySet = require("./getRelayQueries")(Container, queryConfig);

    var request = this.pendingRequest = forceFetch ? onForceFetch ? onForceFetch(querySet, onReadyStateChange) : environment.forceFetch(querySet, onReadyStateChange) : onPrimeCache ? onPrimeCache(querySet, onReadyStateChange) : environment.primeCache(querySet, onReadyStateChange);
    this.lastRequest = request;
  };
  /**
   * @private
   */


  _proto._retry = function _retry() {
    var readyState = this.state.readyState;

    if (readyState && readyState.error) {
      this._runQueries(this.props);

      this.setState({
        readyState: null
      });
    }
  };

  _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {
    if (nextProps.Container !== this.props.Container || nextProps.environment !== this.props.environment || nextProps.queryConfig !== this.props.queryConfig || nextProps.shouldFetch !== this.props.shouldFetch || nextProps.forceFetch && !this.props.forceFetch) {
      this._validateProps(nextProps);

      this._runQueries(nextProps);

      this.setState({
        readyState: null
      });
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    // `prevState` should exist; the truthy check is for Flow soundness.
    var readyState = this.state.readyState;

    if (readyState) {
      if (!prevState || readyState !== prevState.readyState) {
        this._handleReadyStateChange(readyState);
      }
    }
  };
  /**
   * @private
   */


  _proto._handleReadyStateChange = function _handleReadyStateChange(readyState) {
    var onReadyStateChange = this.props.onReadyStateChange;

    if (onReadyStateChange) {
      onReadyStateChange(readyState);
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.pendingRequest) {
      this.pendingRequest.abort();
    }

    this.mounted = false;
  };

  _proto.render = function render() {
    var readyState = this.state.active ? this.state.readyState : INACTIVE_READY_STATE;
    return require("react").createElement(require("./RelayReadyStateRenderer"), {
      Container: this.props.Container,
      environment: this.props.environment,
      queryConfig: this.props.queryConfig,
      readyState: readyState,
      render: this.props.render,
      retry: this.state.retry
    });
  };

  return RelayRenderer;
}(require("react").Component);

(0, _defineProperty2["default"])(RelayRenderer, "propTypes", {
  Container: require("./RelayPropTypes").Container,
  forceFetch: require("prop-types").bool,
  onReadyStateChange: require("prop-types").func,
  queryConfig: require("./RelayPropTypes").QueryConfig.isRequired,
  environment: require("./RelayPropTypes").Environment,
  render: require("prop-types").func,
  shouldFetch: require("prop-types").bool
});
(0, _defineProperty2["default"])(RelayRenderer, "defaultProps", {
  shouldFetch: true
});
module.exports = RelayRenderer;