/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
'use strict';

/**
 * @internal
 *
 * Resolves data from fragment pointers.
 *
 * The supplied `callback` will be invoked whenever data returned by the last
 * invocation to `resolve` has changed.
 */
var GraphQLStoreQueryResolver =
/*#__PURE__*/
function () {
  function GraphQLStoreQueryResolver(storeData, fragment, callback) {
    this.dispose();
    this._callback = callback;
    this._fragment = fragment;
    this._resolver = null;
    this._storeData = storeData;
  }
  /**
   * disposes the resolver's internal state such that future `resolve()` results
   * will not be `===` to previous results, and unsubscribes any subscriptions.
   */


  var _proto = GraphQLStoreQueryResolver.prototype;

  _proto.dispose = function dispose() {
    if (this._resolver) {
      this._resolver.dispose();
    }
  };

  _proto.resolve = function resolve(fragment, dataIDs) {
    // Warn but don't crash if resolved with the wrong fragment.
    if (this._fragment.getConcreteFragmentID() !== fragment.getConcreteFragmentID()) {
      process.env.NODE_ENV !== "production" ? require("fbjs/lib/warning")(false, 'GraphQLStoreQueryResolver: Expected `resolve` to be called with the ' + 'same concrete fragment as the constructor. The resolver was created ' + 'with fragment `%s` but resolved with fragment `%s`.', this._fragment.getDebugName(), fragment.getDebugName()) : void 0;
    } // Rather than crash on mismatched plurality of fragment/ids just warn
    // and resolve as if the fragment's pluarity matched the format of the ids.
    // Note that the inverse - attempt to resolve based on fragment plurarity -
    // doesn't work because there's no way convert plural ids to singular w/o
    // losing data.


    if (Array.isArray(dataIDs)) {
      // Fragment should be plural if data is pluaral.
      process.env.NODE_ENV !== "production" ? require("fbjs/lib/warning")(fragment.isPlural(), 'GraphQLStoreQueryResolver: Expected id/fragment plurality to be ' + 'consistent: got plural ids for singular fragment `%s`.', fragment.getDebugName()) : void 0;
      var resolver = this._resolver;

      if (resolver instanceof GraphQLStoreSingleQueryResolver) {
        resolver.dispose();
        resolver = null;
      }

      if (!resolver) {
        resolver = new GraphQLStorePluralQueryResolver(this._storeData, this._callback);
      }

      this._resolver = resolver;
      return resolver.resolve(fragment, dataIDs);
    } else {
      // Fragment should be singular if data is singular.
      process.env.NODE_ENV !== "production" ? require("fbjs/lib/warning")(!fragment.isPlural(), 'GraphQLStoreQueryResolver: Expected id/fragment plurality to be ' + 'consistent: got a singular id for plural fragment `%s`.', fragment.getDebugName()) : void 0;
      var _resolver = this._resolver;

      if (_resolver instanceof GraphQLStorePluralQueryResolver) {
        _resolver.dispose();

        _resolver = null;
      }

      if (!_resolver) {
        _resolver = new GraphQLStoreSingleQueryResolver(this._storeData, this._callback);
      }

      this._resolver = _resolver;
      return _resolver.resolve(fragment, dataIDs);
    }
  };

  return GraphQLStoreQueryResolver;
}();
/**
 * Resolves plural fragments.
 */


var GraphQLStorePluralQueryResolver =
/*#__PURE__*/
function () {
  function GraphQLStorePluralQueryResolver(storeData, callback) {
    this.dispose();
    this._callback = callback;
    this._storeData = storeData;
  }

  var _proto2 = GraphQLStorePluralQueryResolver.prototype;

  _proto2.dispose = function dispose() {
    if (this._resolvers) {
      this._resolvers.forEach(function (resolver) {
        return resolver.dispose();
      });
    }

    this._resolvers = [];
    this._results = [];
  };
  /**
   * Resolves a plural fragment pointer into an array of records.
   *
   * If the data, order, and number of resolved records has not changed since
   * the last call to `resolve`, the same array will be returned. Otherwise, a
   * new array will be returned.
   */


  _proto2.resolve = function resolve(fragment, nextIDs) {
    var prevResults = this._results;
    var nextResults;
    var prevLength = prevResults.length;
    var nextLength = nextIDs.length;
    var resolvers = this._resolvers; // Ensure that we have exactly `nextLength` resolvers.

    while (resolvers.length < nextLength) {
      resolvers.push(new GraphQLStoreSingleQueryResolver(this._storeData, this._callback));
    }

    while (resolvers.length > nextLength) {
      resolvers.pop().dispose();
    } // Allocate `nextResults` if and only if results have changed.


    if (prevLength !== nextLength) {
      nextResults = [];
    }

    for (var ii = 0; ii < nextLength; ii++) {
      var nextResult = resolvers[ii].resolve(fragment, nextIDs[ii]);

      if (nextResults || ii >= prevLength || nextResult !== prevResults[ii]) {
        nextResults = nextResults || prevResults.slice(0, ii);
        nextResults.push(nextResult);
      }
    }

    if (nextResults) {
      this._results = nextResults;
    }

    return this._results;
  };

  return GraphQLStorePluralQueryResolver;
}();
/**
 * Resolves non-plural fragments.
 */


var GraphQLStoreSingleQueryResolver =
/*#__PURE__*/
function () {
  function GraphQLStoreSingleQueryResolver(storeData, callback) {
    this.dispose();
    this._callback = callback;
    this._storeData = storeData;
    this._subscribedIDs = {};
  }

  var _proto3 = GraphQLStoreSingleQueryResolver.prototype;

  _proto3.dispose = function dispose() {
    if (this._subscription) {
      this._subscription.remove();
    }

    this._hasDataChanged = false;
    this._fragment = null;
    this._result = null;
    this._resultID = null;
    this._subscription = null;
    this._subscribedIDs = {};
  };
  /**
   * Resolves data for a single fragment pointer.
   */


  _proto3.resolve = function resolve(nextFragment, nextID) {
    var prevFragment = this._fragment;
    var prevID = this._resultID;
    var nextResult;
    var prevResult = this._result;
    var subscribedIDs;

    if (prevFragment != null && prevID != null && this._getCanonicalID(prevID) === this._getCanonicalID(nextID)) {
      if (prevID !== nextID || this._hasDataChanged || !nextFragment.isEquivalent(prevFragment)) {
        // same canonical ID,
        // but the data, call(s), route, and/or variables have changed
        var _this$_resolveFragmen = this._resolveFragment(nextFragment, nextID);

        nextResult = _this$_resolveFragmen[0];
        subscribedIDs = _this$_resolveFragmen[1];
        nextResult = require("relay-runtime").recycleNodesInto(prevResult, nextResult);
      } else {
        // same id, route, variables, and data
        nextResult = prevResult;
      }
    } else {
      // Pointer has a different ID or is/was fake data.
      var _this$_resolveFragmen2 = this._resolveFragment(nextFragment, nextID);

      nextResult = _this$_resolveFragmen2[0];
      subscribedIDs = _this$_resolveFragmen2[1];
    } // update subscriptions whenever results change


    if (prevResult !== nextResult) {
      if (this._subscription) {
        this._subscription.remove();

        this._subscription = null;
      }

      if (subscribedIDs) {
        // always subscribe to the root ID
        subscribedIDs[nextID] = true;

        var changeEmitter = this._storeData.getChangeEmitter();

        this._subscription = changeEmitter.addListenerForIDs(Object.keys(subscribedIDs), this._handleChange.bind(this));
        this._subscribedIDs = subscribedIDs;
      }

      this._resultID = nextID;
      this._result = nextResult;
    }

    this._hasDataChanged = false;
    this._fragment = nextFragment;
    return this._result;
  };
  /**
   * Ranges publish events for the entire range, not the specific view of that
   * range. For example, if "client:1" is a range, the event is on "client:1",
   * not "client:1_first(5)".
   */


  _proto3._getCanonicalID = function _getCanonicalID(id) {
    return this._storeData.getRangeData().getCanonicalClientID(id);
  };

  _proto3._handleChange = function _handleChange() {
    if (!this._hasDataChanged) {
      this._hasDataChanged = true;

      this._callback();
    }
  };

  _proto3._resolveFragment = function _resolveFragment(fragment, dataID) {
    var _readRelayQueryData = require("./readRelayQueryData")(this._storeData, fragment, dataID),
        data = _readRelayQueryData.data,
        dataIDs = _readRelayQueryData.dataIDs;

    return [data, dataIDs];
  };

  return GraphQLStoreSingleQueryResolver;
}();

require("relay-runtime").RelayProfiler.instrumentMethods(GraphQLStoreQueryResolver.prototype, {
  resolve: 'GraphQLStoreQueryResolver.resolve'
});

module.exports = GraphQLStoreQueryResolver;