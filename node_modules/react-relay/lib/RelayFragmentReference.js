/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
'use strict';

var _objectSpread2 = require("@babel/runtime/helpers/interopRequireDefault")(require("@babel/runtime/helpers/objectSpread"));

/**
 * @internal
 *
 * RelayFragmentReference is the return type of fragment composition:
 *
 *   fragment on Foo {
 *     ${Child.getFragment('bar', {baz: variables.qux})}
 *   }
 *
 * Whereas a fragment defines a sub-query's structure, a fragment reference is
 * a particular instantiation of the fragment as it is composed within a query
 * or another fragment. It encodes the source fragment, initial variables, and
 * a mapping from variables in the composing query's (or fragment's) scope to
 * variables in the fragment's scope.
 *
 * The variable mapping is represented by `variableMapping`, a dictionary that
 * maps from names of variables in the parent scope to variables that exist in
 * the fragment. Example:
 *
 * ```
 * // Fragment:
 * var Container = Relay.createContainer(..., {
 *   initialVariables: {
 *     private: 'foo',
 *     public: 'bar',
 *     variable: null,
 *   },
 *   fragments: {
 *     foo: ...
 *   }
 * });
 *
 * // Reference:
 * ${Container.getQuery(
 *   'foo',
 *   // Variable Mapping:
 *   {
 *     public: 'BAR',
 *     variable: variables.source,
 *   }
 * )}
 * ```
 *
 * When evaluating the referenced fragment, `$public` will be overridden with
 * `'Bar'`. The value of `$variable` will become the value of `$source` in the
 * outer scope. This is analagous to:
 *
 * ```
 * function inner(private = 'foo', public = 'bar', variable) {}
 * function outer(source) {
 *   inner(public = 'BAR', variable = source);
 * }
 * ```
 *
 * Where the value of the inner `variable` depends on how `outer` is called.
 *
 * The `prepareVariables` function allows for variables to be modified based on
 * the runtime environment or route name.
 */
var RelayFragmentReference =
/*#__PURE__*/
function () {
  RelayFragmentReference.createForContainer = function createForContainer(fragmentGetter, initialVariables, variableMapping, prepareVariables) {
    var reference = new RelayFragmentReference(fragmentGetter, initialVariables, variableMapping, prepareVariables);
    reference._isContainerFragment = true;
    return reference;
  };

  function RelayFragmentReference(fragmentGetter, initialVariables, variableMapping, prepareVariables) {
    this._conditions = null;
    this._initialVariables = initialVariables || {};
    this._fragment = undefined;
    this._fragmentGetter = fragmentGetter;
    this._isContainerFragment = false;
    this._isDeferred = false;
    this._isTypeConditional = false;
    this._variableMapping = variableMapping;
    this._prepareVariables = prepareVariables;
  }

  var _proto = RelayFragmentReference.prototype;

  _proto.conditionOnType = function conditionOnType() {
    this._isTypeConditional = true;
    return this;
  };

  _proto.getConditions = function getConditions() {
    return this._conditions;
  };

  _proto.getFragmentUnconditional = function getFragmentUnconditional() {
    var fragment = this._fragment;

    if (fragment == null) {
      fragment = this._fragmentGetter();
      this._fragment = fragment;
    }

    return fragment;
  };

  _proto.getInitialVariables = function getInitialVariables() {
    return this._initialVariables;
  };

  _proto.getVariableMapping = function getVariableMapping() {
    return this._variableMapping;
  };
  /**
   * Mark this usage of the fragment as deferred.
   */


  _proto.defer = function defer() {
    this._isDeferred = true;
    return this;
  };
  /**
   * Mark this fragment for inclusion only if the given variable is truthy.
   */


  _proto["if"] = function _if(value) {
    var callVariable = require("./QueryBuilder").getCallVariable(value);

    !callVariable ? process.env.NODE_ENV !== "production" ? require("fbjs/lib/invariant")(false, 'RelayFragmentReference: Invalid value `%s` supplied to `if()`. ' + 'Expected a variable.', callVariable) : require("fbjs/lib/invariant")(false) : void 0;

    this._addCondition({
      passingValue: true,
      variable: callVariable.callVariableName
    });

    return this;
  };
  /**
   * Mark this fragment for inclusion only if the given variable is falsy.
   */


  _proto.unless = function unless(value) {
    var callVariable = require("./QueryBuilder").getCallVariable(value);

    !callVariable ? process.env.NODE_ENV !== "production" ? require("fbjs/lib/invariant")(false, 'RelayFragmentReference: Invalid value `%s` supplied to `unless()`. ' + 'Expected a variable.', callVariable) : require("fbjs/lib/invariant")(false) : void 0;

    this._addCondition({
      passingValue: false,
      variable: callVariable.callVariableName
    });

    return this;
  };
  /**
   * Get the referenced fragment if all conditions are met.
   */


  _proto.getFragment = function getFragment(variables) {
    // determine if the variables match the supplied if/unless conditions
    var conditions = this._conditions;

    if (conditions && !conditions.every(function (_ref) {
      var variable = _ref.variable,
          passingValue = _ref.passingValue;
      return !!variables[variable] === passingValue;
    })) {
      return null;
    }

    return this.getFragmentUnconditional();
  };
  /**
   * Get the variables to pass to the referenced fragment, accounting for
   * initial values, overrides, and route-specific variables.
   */


  _proto.getVariables = function getVariables(route, variables) {
    var _this = this;

    var innerVariables = (0, _objectSpread2["default"])({}, this._initialVariables); // map variables from outer -> inner scope

    var variableMapping = this._variableMapping;

    if (variableMapping) {
      require("fbjs/lib/forEachObject")(variableMapping, function (value, name) {
        var callVariable = require("./QueryBuilder").getCallVariable(value);

        if (callVariable) {
          value = variables[callVariable.callVariableName];
        }

        if (value === undefined) {
          process.env.NODE_ENV !== "production" ? require("fbjs/lib/warning")(false, 'RelayFragmentReference: Variable `%s` is undefined in fragment ' + '`%s`.', name, _this.getFragmentUnconditional().name) : void 0;
        } else {
          innerVariables[name] = value;
        }
      });
    }

    var prepareVariables = this._prepareVariables;

    if (prepareVariables) {
      innerVariables = prepareVariables(innerVariables, route);
    }

    return innerVariables;
  };

  _proto.isContainerFragment = function isContainerFragment() {
    return this._isContainerFragment;
  };

  _proto.isDeferred = function isDeferred() {
    return this._isDeferred;
  };

  _proto.isTypeConditional = function isTypeConditional() {
    return this._isTypeConditional;
  };

  _proto._addCondition = function _addCondition(condition) {
    var conditions = this._conditions;

    if (!conditions) {
      conditions = [];
      this._conditions = conditions;
    }

    conditions.push(condition);
  };

  return RelayFragmentReference;
}();

module.exports = RelayFragmentReference;