/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
'use strict';

var _inheritsLoose2 = require("@babel/runtime/helpers/interopRequireDefault")(require("@babel/runtime/helpers/inheritsLoose"));

var MUTATION_STATUS = require("./RelayRecord").MetadataKey.MUTATION_STATUS;

var METADATA_KEYS = ['__status__', '__resolvedFragmentMapGeneration__'];
/**
 * @internal
 *
 * Retrieves data from the `RelayStore`.
 */

function readRelayQueryData(storeData, queryNode, dataID, options) {
  var reader = new RelayStoreReader(storeData, options);
  var data = reader.retrieveData(queryNode, dataID); // We validate only after retrieving the data, to give our `invariant`
  // checks below a chance to fail fast.

  require("./validateRelayReadQuery")(queryNode, options);

  return data;
}

var RelayStoreReader =
/*#__PURE__*/
function (_RelayQueryVisitor) {
  (0, _inheritsLoose2["default"])(RelayStoreReader, _RelayQueryVisitor);

  // GraphQLStoreRangeUtils
  function RelayStoreReader(storeData, options) {
    var _this;

    _this = _RelayQueryVisitor.call(this) || this;
    _this._rangeData = storeData.getRangeData();
    _this._recordStore = storeData.getQueuedStore();
    _this._storeData = storeData;
    _this._traverseFragmentReferences = options && options.traverseFragmentReferences || false;
    _this._traverseGeneratedFields = options && options.traverseGeneratedFields || false;
    return _this;
  }
  /**
   * Runs `queryNode` against the data in `dataID` and returns the result.
   */


  var _proto = RelayStoreReader.prototype;

  _proto.retrieveData = function retrieveData(queryNode, dataID) {
    var result = {
      data: undefined,
      dataIDs: {}
    };

    var rangeData = this._rangeData.parseRangeClientID(dataID);

    var status = this._recordStore.getRecordState(rangeData ? rangeData.dataID : dataID);

    if (status === require("./RelayClassicRecordState").EXISTENT) {
      var state = this._createState({
        componentDataID: null,
        data: undefined,
        isPartial: false,
        parent: null,
        rangeInfo: null,
        seenDataIDs: result.dataIDs,
        storeDataID: dataID
      });

      this.visit(queryNode, state);
      result.data = state.data;
    } else if (status === require("./RelayClassicRecordState").NONEXISTENT) {
      result.data = null;
    }

    return result;
  };

  _proto.visit = function visit(node, state) {
    var result = _RelayQueryVisitor.prototype.visit.call(this, node, state);

    this._updateMetadataFields(state);

    return result;
  };

  _proto.visitField = function visitField(node, state) {
    var _ConnectionInterface$ = require("relay-runtime").ConnectionInterface.get(),
        EDGES = _ConnectionInterface$.EDGES,
        PAGE_INFO = _ConnectionInterface$.PAGE_INFO; // Check for range client IDs (eg. `someID_first(25)`) and unpack if
    // present, overriding `state`.


    this._handleRangeInfo(node, state);

    if (node.canHaveSubselections() || node.isGenerated()) {
      // Make sure we return at least the __dataID__.
      getDataObject(state);
    }

    if (node.isGenerated() && !this._traverseGeneratedFields) {
      return;
    }

    var rangeInfo = state.rangeInfo;

    if (rangeInfo && node.getSchemaName() === EDGES) {
      this._readEdges(node, rangeInfo, state);
    } else if (rangeInfo && node.getSchemaName() === PAGE_INFO) {
      this._readPageInfo(node, rangeInfo, state);
    } else if (!node.canHaveSubselections()) {
      this._readScalar(node, state);
    } else if (node.isPlural()) {
      this._readPlural(node, state);
    } else if (node.isConnection()) {
      this._readConnection(node, state);
    } else {
      this._readLinkedField(node, state);
    }

    state.seenDataIDs[state.storeDataID] = true;
  };

  _proto.visitFragment = function visitFragment(node, state) {
    var dataID = getComponentDataID(state);

    if (node.isContainerFragment() && !this._traverseFragmentReferences) {
      state.seenDataIDs[dataID] = true;
      var data = getDataObject(state);

      require("./RelayFragmentPointer").addFragment(data, node);
    } else if (require("./isCompatibleRelayFragmentType")(node, this._recordStore.getType(dataID))) {
      this.traverse(node, state);
    }
  };

  _proto._createState = function _createState(state) {
    // If we have a valid `dataID`, ensure that a record is created for it even
    // if we do not actually end up populating it with fields.
    var status = this._recordStore.getRecordState(state.storeDataID);

    if (status === require("./RelayClassicRecordState").EXISTENT) {
      getDataObject(state);
    }

    return state;
  };

  _proto._readScalar = function _readScalar(node, state) {
    var storageKey = node.getStorageKey();

    var field = this._recordStore.getField(state.storeDataID, storageKey);

    if (field === undefined) {
      state.isPartial = true;
    } else if (field === null && !state.data) {
      state.data = null;
    } else {
      this._setDataValue(state, node.getApplicationName(), Array.isArray(field) ? field.slice() : field);
    }
  };

  _proto._readPlural = function _readPlural(node, state) {
    var _this2 = this;

    var storageKey = node.getStorageKey();

    var dataIDs = this._recordStore.getLinkedRecordIDs(state.storeDataID, storageKey);

    if (dataIDs) {
      var applicationName = node.getApplicationName();
      var previousData = getDataValue(state, applicationName);
      var nextData = dataIDs.map(function (dataID, ii) {
        var data;

        if (previousData instanceof Object) {
          data = previousData[ii];
        }

        var nextState = _this2._createState({
          componentDataID: null,
          data: data,
          isPartial: false,
          parent: node,
          rangeInfo: null,
          seenDataIDs: state.seenDataIDs,
          storeDataID: dataID
        });

        node.getChildren().forEach(function (child) {
          return _this2.visit(child, nextState);
        });

        if (nextState.isPartial) {
          state.isPartial = true;
        }

        return nextState.data;
      });

      this._setDataValue(state, applicationName, nextData);
    }
  };

  _proto._readConnection = function _readConnection(node, state) {
    var applicationName = node.getApplicationName();
    var storageKey = node.getStorageKey();
    var calls = node.getCallsWithValues();

    var dataID = this._recordStore.getLinkedRecordID(state.storeDataID, storageKey);

    if (!dataID) {
      state.isPartial = true;
      return;
    }

    enforceRangeCalls(node);

    var metadata = this._recordStore.getRangeMetadata(dataID, calls);

    var nextState = this._createState({
      componentDataID: this._getConnectionClientID(node, dataID),
      data: getDataValue(state, applicationName),
      isPartial: false,
      parent: node,
      rangeInfo: metadata && calls.length ? metadata : null,
      seenDataIDs: state.seenDataIDs,
      storeDataID: dataID
    });

    this.traverse(node, nextState);

    if (nextState.isPartial) {
      state.isPartial = true;
    }

    this._setDataValue(state, applicationName, nextState.data);
  };

  _proto._readEdges = function _readEdges(node, rangeInfo, state) {
    var _this3 = this;

    var _ConnectionInterface$2 = require("relay-runtime").ConnectionInterface.get(),
        EDGES = _ConnectionInterface$2.EDGES;

    if (rangeInfo.diffCalls.length) {
      state.isPartial = true;
    }

    var previousData = getDataValue(state, EDGES); // Include null-filtered edges as "seen" so that they will be subscribed.

    rangeInfo.requestedEdgeIDs.forEach(function (edgeID) {
      state.seenDataIDs[edgeID] = true;
    });
    var edges = rangeInfo.filteredEdges.map(function (edgeData, ii) {
      var data;

      if (previousData instanceof Object) {
        data = previousData[ii];
      }

      var nextState = _this3._createState({
        componentDataID: null,
        data: data,
        isPartial: false,
        parent: node,
        rangeInfo: null,
        seenDataIDs: state.seenDataIDs,
        storeDataID: edgeData.edgeID
      });

      _this3.traverse(node, nextState);

      if (nextState.isPartial) {
        state.isPartial = true;
      }

      return nextState.data;
    });

    this._setDataValue(state, EDGES, edges);
  };

  _proto._readPageInfo = function _readPageInfo(node, rangeInfo, state) {
    var _this4 = this;

    var _ConnectionInterface$3 = require("relay-runtime").ConnectionInterface.get(),
        PAGE_INFO = _ConnectionInterface$3.PAGE_INFO;

    var pageInfo = rangeInfo.pageInfo;
    !pageInfo ? process.env.NODE_ENV !== "production" ? require("fbjs/lib/invariant")(false, 'readRelayQueryData(): Missing field, `%s`.', PAGE_INFO) : require("fbjs/lib/invariant")(false) : void 0;

    if (rangeInfo.diffCalls.length) {
      state.isPartial = true;
    }

    var info = pageInfo; // for Flow

    var nextData; // Page info comes from the range metadata, so we do a custom traversal here
    // which is simpler than passing through page-info-related state as a hint
    // for the normal traversal.

    var read = function read(child) {
      if (child instanceof require("./RelayQuery").Fragment) {
        if (child.isContainerFragment() && !_this4._traverseFragmentReferences) {
          nextData = nextData || {};

          require("./RelayFragmentPointer").addFragment(nextData, child);
        } else {
          child.getChildren().forEach(read);
        }
      } else {
        var field = child;

        if (!field.isGenerated() || _this4._traverseGeneratedFields) {
          nextData = nextData || {};
          nextData[field.getApplicationName()] = info[field.getStorageKey()];
        }
      }
    };

    node.getChildren().forEach(read);

    this._setDataValue(state, node.getApplicationName(), nextData);
  };

  _proto._readLinkedField = function _readLinkedField(node, state) {
    var storageKey = node.getStorageKey();
    var applicationName = node.getApplicationName();

    var dataID = this._recordStore.getLinkedRecordID(state.storeDataID, storageKey);

    if (dataID == null) {
      if (dataID === undefined) {
        state.isPartial = true;
      }

      this._setDataValue(state, applicationName, dataID);

      return;
    }

    var nextState = this._createState({
      componentDataID: null,
      data: getDataValue(state, applicationName),
      isPartial: false,
      parent: node,
      rangeInfo: null,
      seenDataIDs: state.seenDataIDs,
      storeDataID: dataID
    });

    this.traverse(node, nextState);

    if (nextState.isPartial) {
      state.isPartial = true;
    }

    this._setDataValue(state, applicationName, nextState.data);
  };
  /**
   * Assigns `value` to the property of `state.data` identified by `key`.
   *
   * Pre-populates `state` with a suitable `data` object if needed, and copies
   * over any metadata fields, if present.
   */


  _proto._setDataValue = function _setDataValue(state, key, value) {
    var data = getDataObject(state); // ensure __dataID__

    if (value === undefined) {
      return;
    }

    data[key] = value;
  };

  _proto._updateMetadataFields = function _updateMetadataFields(state) {
    var _this5 = this;

    var data = state.data;

    if (!(data instanceof Object)) {
      return;
    }

    var dataID = state.storeDataID; // Copy metadata that is necessary to dirty records when recycling objects.

    METADATA_KEYS.forEach(function (metadataKey) {
      var metadataValue = _this5._recordStore.getField(dataID, metadataKey);

      if (metadataValue != null) {
        data[metadataKey] = metadataValue;
      }
    }); // Set the partial bit after metadata has been copied over.

    if (state.isPartial) {
      data.__status__ = require("./RelayRecordStatusMap").setPartialStatus(data.__status__, true);
    } // Hash any pending mutation transactions.


    var mutationIDs = this._storeData.getClientMutationIDs(dataID);

    if (mutationIDs) {
      var statuses = [];

      var mutationQueue = this._storeData.getMutationQueue();

      mutationIDs.forEach(function (mutationID) {
        var transaction = mutationQueue.getTransaction(mutationID);

        if (transaction) {
          statuses.push(transaction.getHash());
        }
      });
      data[MUTATION_STATUS] = statuses.join(',');
    }
  };
  /**
   * Obtains a client ID (eg. `someDataID_first(10)`) for the connection
   * identified by `connectionID`. If there are no range calls on the supplied
   * `node`, then a call-less connection ID (eg. `someDataID`) will be returned
   * instead.
   */


  _proto._getConnectionClientID = function _getConnectionClientID(node, connectionID) {
    var calls = node.getCallsWithValues();

    if (!require("relay-runtime").ConnectionInterface.hasRangeCalls(calls)) {
      return connectionID;
    }

    return this._rangeData.getClientIDForRangeWithID(require("./callsToGraphQL")(calls), {}, connectionID);
  };
  /**
   * Checks to see if we have a range client ID (eg. `someID_first(25)`), and if
   * so, unpacks the range metadata, stashing it into (and overriding) `state`.
   */


  _proto._handleRangeInfo = function _handleRangeInfo(node, state) {
    var rangeData = this._rangeData.parseRangeClientID(state.storeDataID);

    if (rangeData != null) {
      state.componentDataID = state.storeDataID;
      state.storeDataID = rangeData.dataID;
      state.rangeInfo = this._recordStore.getRangeMetadata(state.storeDataID, require("./callsFromGraphQL")(rangeData.calls, rangeData.callValues));
    }
  };

  return RelayStoreReader;
}(require("./RelayQueryVisitor"));
/**
 * Checks that `parent` either has range calls on it or does not contain either
 * `page_info` or `edges` fields. This enforcement intentionally transcends
 * traverseFragmentReferences boundaries.
 */


function enforceRangeCalls(parent) {
  if (!parent.__hasValidatedConnectionCalls__) {
    var calls = parent.getCallsWithValues();

    if (!require("relay-runtime").ConnectionInterface.hasRangeCalls(calls)) {
      rangeCallEnforcer.traverse(parent, parent);
    }

    parent.__hasValidatedConnectionCalls__ = true;
  }
}

var RelayRangeCallEnforcer =
/*#__PURE__*/
function (_RelayQueryVisitor2) {
  (0, _inheritsLoose2["default"])(RelayRangeCallEnforcer, _RelayQueryVisitor2);

  function RelayRangeCallEnforcer() {
    return _RelayQueryVisitor2.apply(this, arguments) || this;
  }

  var _proto2 = RelayRangeCallEnforcer.prototype;

  _proto2.visitField = function visitField(node, parent) {
    var _ConnectionInterface$4 = require("relay-runtime").ConnectionInterface.get(),
        EDGES = _ConnectionInterface$4.EDGES,
        PAGE_INFO = _ConnectionInterface$4.PAGE_INFO;

    var schemaName = node.getSchemaName();
    !(schemaName !== EDGES && schemaName !== PAGE_INFO) ? process.env.NODE_ENV !== "production" ? require("fbjs/lib/invariant")(false, 'readRelayQueryData(): The field `%s` is a connection. Fields `%s` and ' + '`%s` cannot be fetched without a `first`, `last` or `find` argument.', parent.getApplicationName(), EDGES, PAGE_INFO) : require("fbjs/lib/invariant")(false) : void 0;
  };

  return RelayRangeCallEnforcer;
}(require("./RelayQueryVisitor"));

var rangeCallEnforcer = new RelayRangeCallEnforcer();
/**
 * Returns the component-specific DataID stored in `state`, falling back to the
 * generic "store" DataID.
 *
 * For most nodes, the generic "store" DataID can be used for both reading out
 * of the store and writing into the result object that will be passed back to
 * the component. For connections with range calls on them the "store" and
 * "component" ID will be different because the component needs a special
 * client-ID that encodes the range calls.
 */

function getComponentDataID(state) {
  if (state.componentDataID != null) {
    return state.componentDataID;
  } else {
    return state.storeDataID;
  }
}
/**
 * Retrieves `state.data`, initializing it if necessary.
 */


function getDataObject(state) {
  var data = state.data;

  if (!data) {
    data = state.data = require("./RelayRecord").create(getComponentDataID(state));
  }

  !(data instanceof Object) ? process.env.NODE_ENV !== "production" ? require("fbjs/lib/invariant")(false, 'readRelayQueryData(): Unable to read field on non-object.') : require("fbjs/lib/invariant")(false) : void 0;
  return data;
}
/**
 * Looks up the value identified by `key` in `state.data`.
 *
 * Pre-populates `state` with a suitable `data` objects if needed.
 */


function getDataValue(state, key) {
  var data = getDataObject(state);
  return data[key];
}

module.exports = require("relay-runtime").RelayProfiler.instrument('readRelayQueryData', readRelayQueryData);