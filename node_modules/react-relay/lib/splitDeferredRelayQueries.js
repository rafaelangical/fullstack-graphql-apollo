/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
'use strict';

var _inheritsLoose2 = require("@babel/runtime/helpers/interopRequireDefault")(require("@babel/runtime/helpers/inheritsLoose"));

/**
 * Traverse `node` splitting off deferred query fragments into separate queries.
 *
 * @internal
 */
function splitDeferredRelayQueries(node) {
  var splitter = new GraphQLSplitDeferredQueries();
  var splitQueries = {
    __nodePath__: [],
    __parent__: null,
    __refQuery__: null,
    deferred: [],
    required: null
  };
  splitter.visit(node, splitQueries);
  return buildQueries(splitQueries);
}
/**
 * Returns the requisite siblings of `node`, but filters any non-requisite
 * children of those siblings.
 */


function getRequisiteSiblings(node, parent) {
  // Get the requisite siblings.
  var siblings = parent.getChildren().filter(function (child) {
    return child !== node && child instanceof require("./RelayQuery").Field && child.isRequisite();
  }); // Filter the non-requisite children from those siblings.

  return siblings.map(function (sibling) {
    var children = sibling.getChildren().filter(function (child) {
      return child instanceof require("./RelayQuery").Field && child.isRequisite();
    });
    var clone = sibling.clone(children);
    !clone ? process.env.NODE_ENV !== "production" ? require("fbjs/lib/invariant")(false, 'splitDeferredRelayQueries(): Unexpected non-scalar, requisite field.') : require("fbjs/lib/invariant")(false) : void 0;
    return clone;
  });
}
/**
 * Traverse the parent chain of `node` wrapping it at each level until it is
 * either:
 *
 * - wrapped in a RelayQuery.Root node
 * - wrapped in a non-root node that can be split off in a "ref query" (ie. a
 *   root call with a ref param that references another query)
 *
 * Additionally ensures that any requisite sibling fields are embedded in each
 * layer of the wrapper.
 */


function wrapNode(node, nodePath) {
  for (var ii = nodePath.length - 1; ii >= 0; ii--) {
    var parent = nodePath[ii];

    if (parent instanceof require("./RelayQuery").Field && parent.getInferredRootCallName()) {
      // We can make a "ref query" at this point, so stop wrapping.
      return new (require("./RelayRefQueryDescriptor"))(node, nodePath.slice(0, ii + 1));
    }

    var siblings = getRequisiteSiblings(node, parent);
    var children = [node].concat(siblings); // Cast here because we know that `clone` will never return `null` (because
    // we always give it at least one child).

    node = parent.clone(children);
  }

  !(node instanceof require("./RelayQuery").Root) ? process.env.NODE_ENV !== "production" ? require("fbjs/lib/invariant")(false, 'splitDeferredRelayQueries(): Cannot build query without a root node.') : require("fbjs/lib/invariant")(false) : void 0;
  var identifyingArg = node.getIdentifyingArg();
  var identifyingArgName = identifyingArg && identifyingArg.name || null;
  var identifyingArgValue = identifyingArg && identifyingArg.value || null;

  var identifyingArgType = identifyingArg && identifyingArg.type || require("./RelayNodeInterface").ID_TYPE;

  var metadata = {
    identifyingArgName: identifyingArgName,
    identifyingArgType: identifyingArgType,
    isAbstract: true,
    isDeferred: true,
    isPlural: false
  };
  return require("./RelayQuery").Root.build(node.getName(), node.getFieldName(), identifyingArgValue, node.getChildren(), metadata, node.getType());
}
/**
 * Returns `true` if `node` is considered "empty", which means that it contains
 * no non-generated fields, and no ref query dependencies.
 */


function isEmpty(node) {
  if (!node.canHaveSubselections()) {
    return node.isGenerated() && !node.isRefQueryDependency();
  } else {
    return node.getChildren().every(isEmpty);
  }
}
/**
 * Mutates and returns a nested `SplitQueries` structure, updating any deferred
 * "ref queries" to actually reference their contexts.
 */


function buildQueries(splitQueries) {
  if (splitQueries.required && isEmpty(splitQueries.required)) {
    splitQueries.required = null;
  }

  splitQueries.deferred = splitQueries.deferred.map(function (nestedSplitQueries) {
    var descriptor = nestedSplitQueries.__refQuery__;

    if (descriptor) {
      // Wrap the ref query node with a reference to the required query that is
      // its context.
      var context = splitQueries.required;

      if (!context) {
        // Traverse upwards looking for context.
        var parentSplitQueries = splitQueries;

        while (parentSplitQueries.__parent__) {
          context = parentSplitQueries.__parent__.required;

          if (context) {
            break;
          }

          parentSplitQueries = parentSplitQueries.__parent__;
        }
      }

      !context ? process.env.NODE_ENV !== "production" ? require("fbjs/lib/invariant")(false, 'splitDeferredRelayQueries(): Expected a context root query.') : require("fbjs/lib/invariant")(false) : void 0;
      nestedSplitQueries.required = createRefQuery(descriptor, context);
    }

    return buildQueries(nestedSplitQueries);
  });
  return splitQueries;
}
/**
 * Wraps `descriptor` in a new top-level ref query.
 */


function createRefQuery(descriptor, context) {
  var node = descriptor.node;
  !(node instanceof require("./RelayQuery").Field || node instanceof require("./RelayQuery").Fragment) ? process.env.NODE_ENV !== "production" ? require("fbjs/lib/invariant")(false, 'splitDeferredRelayQueries(): Ref query requires a field or fragment.') : require("fbjs/lib/invariant")(false) : void 0; // Build up JSONPath.

  var jsonPath = ['$', '*'];
  var parent;

  for (var ii = 0; ii < descriptor.nodePath.length; ii++) {
    parent = descriptor.nodePath[ii];

    if (parent instanceof require("./RelayQuery").Field) {
      jsonPath.push(parent.getSerializationKey());

      if (parent.isPlural()) {
        jsonPath.push('*');
      }
    }
  }

  !(jsonPath.length > 2) ? process.env.NODE_ENV !== "production" ? require("fbjs/lib/invariant")(false, 'splitDeferredRelayQueries(): Ref query requires a complete path.') : require("fbjs/lib/invariant")(false) : void 0;
  var field = parent; // Flow

  var primaryKey = field.getInferredPrimaryKey();
  !primaryKey ? process.env.NODE_ENV !== "production" ? require("fbjs/lib/invariant")(false, 'splitDeferredRelayQueries(): Ref query requires a primary key.') : require("fbjs/lib/invariant")(false) : void 0;
  jsonPath.push(primaryKey); // Create the wrapper root query.

  var root = require("./RelayQuery").Root.build(context.getName(), require("./RelayNodeInterface").NODES, require("./QueryBuilder").createBatchCallVariable(context.getID(), jsonPath.join('.')), [node], {
    identifyingArgName: require("./RelayNodeInterface").ID,
    identifyingArgType: require("./RelayNodeInterface").ID_TYPE,
    isAbstract: true,
    isDeferred: true,
    isPlural: false
  }, require("./RelayNodeInterface").NODE_TYPE);

  var result = root; // Flow

  return result;
}
/**
 * Traverses an input query, updating the passed in `SplitQueries` state object
 * to contain a nested structure representing the required and deferred portions
 * of the input query.
 */


var GraphQLSplitDeferredQueries =
/*#__PURE__*/
function (_RelayQueryTransform) {
  (0, _inheritsLoose2["default"])(GraphQLSplitDeferredQueries, _RelayQueryTransform);

  function GraphQLSplitDeferredQueries() {
    return _RelayQueryTransform.apply(this, arguments) || this;
  }

  var _proto = GraphQLSplitDeferredQueries.prototype;

  _proto.visitField = function visitField(node, splitQueries) {
    if (!node.hasDeferredDescendant()) {
      return node;
    }

    splitQueries.__nodePath__.push(node);

    var result = this.traverse(node, splitQueries);

    splitQueries.__nodePath__.pop();

    if (result && node.getInferredRootCallName()) {
      // The node is a ref query dependency; mark it as one.
      var key = node.getInferredPrimaryKey();
      var children = result.getChildren().map(function (child) {
        if (child instanceof require("./RelayQuery").Field && child.getSchemaName() === key) {
          return child.cloneAsRefQueryDependency();
        } else {
          return child;
        }
      });
      result = result.clone(children);
    }

    return result;
  };

  _proto.visitFragment = function visitFragment(node, splitQueries) {
    if (!node.getChildren().length) {
      return null;
    }

    if (node.isDeferred()) {
      var nodePath = splitQueries.__nodePath__;
      var deferred = {
        __nodePath__: nodePath,
        __parent__: splitQueries,
        __refQuery__: null,
        deferred: [],
        required: null
      };
      var result = this.traverse(node, deferred);

      if (result) {
        var wrapped = wrapNode(result, nodePath);

        if (wrapped instanceof require("./RelayQuery").Root) {
          deferred.required = wrapped;
        } else if (wrapped instanceof require("./RelayRefQueryDescriptor")) {
          // for Flow
          deferred.__refQuery__ = wrapped;
        }
      }

      if (result || deferred.deferred.length) {
        splitQueries.deferred.push(deferred);
      }

      return null;
    } else if (node.hasDeferredDescendant()) {
      return this.traverse(node, splitQueries);
    } else {
      return node;
    }
  };

  _proto.visitRoot = function visitRoot(node, splitQueries) {
    if (!node.hasDeferredDescendant()) {
      splitQueries.required = node;
      return node;
    } else {
      splitQueries.__nodePath__.push(node);

      var result = this.traverse(node, splitQueries);

      splitQueries.__nodePath__.pop();

      splitQueries.required = result;
      return result;
    }
  };

  return GraphQLSplitDeferredQueries;
}(require("./RelayQueryTransform"));

module.exports = require("relay-runtime").RelayProfiler.instrument('splitDeferredRelayQueries', splitDeferredRelayQueries);