/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict-local
 * @format
 */
'use strict';

/**
 * Find the definition of a field of the specified type using strict
 * resolution rules per the GraphQL spec.
 */
function getFieldDefinitionStrict(schema, parentType, fieldName, fieldAST) {
  var type = require("./GraphQLSchemaUtils").getRawType(parentType);

  var isQueryType = type === schema.getQueryType();

  var hasTypeName = type instanceof require("graphql").GraphQLObjectType || type instanceof require("graphql").GraphQLInterfaceType || type instanceof require("graphql").GraphQLUnionType;

  var schemaFieldDef;

  if (isQueryType && fieldName === require("graphql").SchemaMetaFieldDef.name) {
    schemaFieldDef = require("graphql").SchemaMetaFieldDef;
  } else if (isQueryType && fieldName === require("graphql").TypeMetaFieldDef.name) {
    schemaFieldDef = require("graphql").TypeMetaFieldDef;
  } else if (hasTypeName && fieldName === require("graphql").TypeNameMetaFieldDef.name) {
    schemaFieldDef = require("graphql").TypeNameMetaFieldDef;
  } else if (type instanceof require("graphql").GraphQLInterfaceType || type instanceof require("graphql").GraphQLObjectType) {
    schemaFieldDef = type.getFields()[fieldName];
  }

  return schemaFieldDef;
}
/**
 * Find the definition of a field of the specified type, first trying
 * the standard spec-compliant resolution process and falling back
 * to legacy mode that supports fat interfaces.
 */


function getFieldDefinitionLegacy(schema, parentType, fieldName, fieldAST) {
  var schemaFieldDef = getFieldDefinitionStrict(schema, parentType, fieldName, fieldAST);

  if (!schemaFieldDef) {
    var type = require("./GraphQLSchemaUtils").getRawType(parentType);

    schemaFieldDef = getFieldDefinitionLegacyImpl(schema, type, fieldName, fieldAST);
  }

  return schemaFieldDef || null;
}
/**
 * @private
 */


function getFieldDefinitionLegacyImpl(schema, type, fieldName, fieldAST) {
  if (require("graphql").isAbstractType(type) && fieldAST && fieldAST.directives && fieldAST.directives.some(function (directive) {
    return getName(directive) === 'fixme_fat_interface';
  })) {
    var possibleTypes = schema.getPossibleTypes(require("graphql").assertAbstractType(type));
    var schemaFieldDef;

    var _loop = function _loop(ii) {
      var possibleField = possibleTypes[ii].getFields()[fieldName];

      if (possibleField) {
        // Fat interface fields can have differing arguments. Try to return
        // a field with matching arguments, but still return a field if the
        // arguments do not match.
        schemaFieldDef = possibleField;

        if (fieldAST && fieldAST.arguments) {
          var argumentsAllExist = fieldAST.arguments.every(function (argument) {
            return possibleField.args.find(function (argDef) {
              return argDef.name === getName(argument);
            });
          });

          if (argumentsAllExist) {
            return "break";
          }
        }
      }
    };

    for (var ii = 0; ii < possibleTypes.length; ii++) {
      var _ret = _loop(ii);

      if (_ret === "break") break;
    }

    return schemaFieldDef;
  }
}
/**
 * @private
 */


function getName(ast) {
  var name = ast.name ? ast.name.value : null;

  if (typeof name !== 'string') {
    throw require("./RelayCompilerError").createCompilerError("Expected ast node to have a 'name'.", null, [ast]);
  }

  return name;
}

module.exports = {
  getFieldDefinitionLegacy: getFieldDefinitionLegacy,
  getFieldDefinitionStrict: getFieldDefinitionStrict
};