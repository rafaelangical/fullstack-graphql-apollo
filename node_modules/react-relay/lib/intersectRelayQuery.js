/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
'use strict';

var _inheritsLoose2 = require("@babel/runtime/helpers/interopRequireDefault")(require("@babel/runtime/helpers/inheritsLoose"));

/**
 * @internal
 *
 * `intersectRelayQuery(subjectNode, patternNode)` returns a node with fields in
 * `subjectNode` that also exist in `patternNode`. `patternNode` is expected to
 * be flattened (and not contain fragments).
 *
 * If any field in `patternNode` is unterminated (i.e. has no sub-fields), we
 * treat the field as though it contains every descendant sub-field.
 *
 * If `filterUnterminatedRange` is supplied, it will be invoked with any fields
 * from `subjectNode` that are connections and unterminated in `patternNode`. If
 * it returns true, the `edges` and `page_info` fields will be filtered out.
 */
function intersectRelayQuery(subjectNode, patternNode, filterUnterminatedRange) {
  filterUnterminatedRange = filterUnterminatedRange || returnsFalse;
  var visitor = new RelayQueryIntersector(filterUnterminatedRange);
  return visitor.traverse(subjectNode, patternNode);
}

var RelayQueryIntersector =
/*#__PURE__*/
function (_RelayQueryTransform) {
  (0, _inheritsLoose2["default"])(RelayQueryIntersector, _RelayQueryTransform);

  function RelayQueryIntersector(filterUnterminatedRange) {
    var _this;

    _this = _RelayQueryTransform.call(this) || this;
    _this._filterUnterminatedRange = filterUnterminatedRange;
    return _this;
  }

  var _proto = RelayQueryIntersector.prototype;

  _proto.traverse = function traverse(subjectNode, patternNode) {
    var _this2 = this;

    if (!subjectNode.canHaveSubselections()) {
      // Since `patternNode` exists, `subjectNode` must be in the intersection.
      return subjectNode;
    }

    if (!hasChildren(patternNode)) {
      if (subjectNode instanceof require("./RelayQuery").Field && subjectNode.isConnection() && this._filterUnterminatedRange(subjectNode)) {
        return filterRangeFields(subjectNode);
      } // Unterminated `patternNode` is the same as containing every descendant
      // sub-field, so `subjectNode` must be in the intersection.


      return subjectNode;
    }

    return subjectNode.clone(subjectNode.getChildren().map(function (subjectChild) {
      if (subjectChild instanceof require("./RelayQuery").Fragment) {
        return _this2.visit(subjectChild, patternNode);
      }

      if (subjectChild instanceof require("./RelayQuery").Field) {
        var schemaName = subjectChild.getSchemaName();
        var patternChild;
        var patternChildren = patternNode.getChildren();

        for (var ii = 0; ii < patternChildren.length; ii++) {
          var child = patternChildren[ii];
          !(child instanceof require("./RelayQuery").Field) ? process.env.NODE_ENV !== "production" ? require("fbjs/lib/invariant")(false, 'intersectRelayQuery(): Nodes in `patternNode` must be fields.') : require("fbjs/lib/invariant")(false) : void 0;

          if (child.getSchemaName() === schemaName) {
            patternChild = child;
            break;
          }
        }

        if (patternChild) {
          return _this2.visit(subjectChild, patternChild);
        }
      }

      return null;
    }));
  };

  return RelayQueryIntersector;
}(require("./RelayQueryTransform"));
/**
 * @private
 */


var RelayQueryRangeFilter =
/*#__PURE__*/
function (_RelayQueryTransform2) {
  (0, _inheritsLoose2["default"])(RelayQueryRangeFilter, _RelayQueryTransform2);

  function RelayQueryRangeFilter() {
    return _RelayQueryTransform2.apply(this, arguments) || this;
  }

  var _proto2 = RelayQueryRangeFilter.prototype;

  _proto2.visitField = function visitField(node) {
    var _ConnectionInterface$ = require("relay-runtime").ConnectionInterface.get(),
        EDGES = _ConnectionInterface$.EDGES,
        PAGE_INFO = _ConnectionInterface$.PAGE_INFO;

    var schemaName = node.getSchemaName();

    if (schemaName === EDGES || schemaName === PAGE_INFO) {
      return null;
    } else {
      return node;
    }
  };

  return RelayQueryRangeFilter;
}(require("./RelayQueryTransform"));

var rangeFilter = new RelayQueryRangeFilter();

function filterRangeFields(node) {
  return rangeFilter.traverse(node, undefined);
}

function returnsFalse() {
  return false;
}

function hasChildren(node) {
  return !node.getChildren().every(isGenerated);
}

function isGenerated(node) {
  return node.isGenerated();
}

module.exports = intersectRelayQuery;